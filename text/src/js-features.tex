% В таблице \ref{tab:features} перечислен краткий список архитектурных
\label{sec:features}
В таблице перечислен краткий список архитектурных
особенностей языка \texttt{JavaScript} стандарта ECMA-262 третьей
редакции \cite{specification1999standard}, важных с точки зрения
статического анализа. 

% features table ::{
\begin{description}
    \item[\emph{Интерпретируемость}]~\\  %::{
 \texttt{JavaScript} это интерпретируемый язык. Перед выполнением не
    преобразовывается в промежуточное представление.
    
    %}::
    \item[\emph{Система типов}]~\\  %::{
    Все типы языка разделяются на элементарные типы и объекты. К
    элеметарным типам относятся \texttt{Undefined}, \texttt{Null},
    \texttt{Boolean}, \texttt{String} и \texttt{Number}. Все объекты,
    как стандартные, включая массивы и функции, так и определённые
    пользователем наследуются от стандартного встроенного объекта
    \texttt{Object}.
    В языке используется слабая динамическая типизация. Почти все
    элементарные типы неявно преобразовываются друг в друга (кроме
    значений типа \texttt{Undefined}). Если переменная содержит
    значение типа \texttt{Boolean}, \texttt{String} или
    \texttt{Number}, то при необходимости оно преобразовывается в
    соответствующий ему стандартный объект.
    %}::
    \item[\emph{Объект \texttt{Object}}]~\\  %::{
    C точки зрения спецификации, объект представляет собой множество
    членов, каждый из которых содержит следующие аттрибуты:
    % содержимое членов объекта ::{
    \begin{itemize}
      \item \inncom{Name} -- имя члена. Имеет тип \texttt{string}.

      \item \inncom{Value} -- значение сопоставленное члену. Может быть
	любого типа.

      \item Множество из нуля или более следующих аттрибутов:
	\begin{itemize}
	  \item \inncom{ReadOnly} -- имеет тип \texttt{boolean}. Если
	    значение истинно, то этот член доступен только для
	    чтения. Попытки записать в этот член будут проигнорированы.

	  \item \inncom{DontEnum}-- имеет тип \texttt{boolean}.
	    Если значений истинно, то член не будет перечисляться
	    внутри цикла \texttt{for-in}.

	  \item \inncom{DontDelete} -- имеет тип \texttt{boolean}. Если
	    значение истинно, то все попытки удалить свойство будут
	    проигнорированы.

	  \item Internal -- внутренние свойства напрямую недоступные
	    через операторы языка. Необходимы для описания
	    поведения. Каждый объект имеет следующие внутренние
	    свойства:
	    \begin{itemize}
	      \item \inncom{Prototype} -- указатель на прототип этого
		объекта. Его назначение описано в пункте \emph{наследование}.
	      \item \inncom{Class} -- строка содержащая класс объекта.
	      \item \inncom{Get} -- функция, возвращающая значение
		указываемого свойства.
	      \item \inncom{Put} -- функция, устанавливающая значение
		указываемого свойства.
	      \item \inncom{CanPut} -- функция, возвращающая значение
		типа \texttt{boolean}, описывающее можно ли успешно
		изменить значение указанного свойства.
	      \item \inncom{HasProperty} -- функция, возвращающая
		значение типа \texttt{boolean}, описывающее,
		существует ли уже у объекта свойство с данным именем.
	      \item \inncom{Delete} -- функция, удаляющая из объекта
		указываемое свойство.
	    \end{itemize}
	\end{itemize}
    \end{itemize}
    С точки зрения пользователя, объект представляется собой
    ассоциативный массив, ключами которого являются строки c именами
    аттрибутов и методов, а значениями являются соответствующие
    объекты. К свойству объекту в программе можно неявно, используя
    его имя (строку). В случае если свойства с запрашиваемым именем не
    существует, то возвращается значение по умолчанию. Поэтому, можно
    сказать, что объект отображает множество всевозможных строк на
    множество объектов.
    %}::
    %}::
    \item[\emph{Наследование}]~\\  %::{
    В языке реализована прототип-ориентированная парадигма
    программирования: отсутствует понятие класса, но существует
    понятие объекта; объекты могут создаваться либо заново,
    перечислением своих методов и атрибутов, либо путём
    клонирования существующих. В последнем случае атрибуты и методы
    базового объекта разделяются между ним и производными объектами.
    Если атрибут базового объекта будет изменён, то эти изменения
    будут видны и в производных объектах. Однако, если в производном
    объекте попытаться изменить атрибут базового объекта, например при
    помощи присваивания, то в производном объекте неявно создастся
    одноименный атрибут, а атрибут базового объекта неизменится.

    Это реализовано при помощи цепей наследования. Каждый объект
    содержит атрибут \texttt{prototype}, который ссылается либо на
    создавший его объект. Если объект был создан заново, перечислением
    свойств, то этот атрибут ссылается на стандартный объект
    \texttt{Object.prototype}, атрибут \texttt{prototype} которого
    ссылается на \texttt{null}.

    При обращении к некоторому свойству объекта (то есть вызове метода
    \inncom{Get}) он сначала ищется среди собственных атрибутов
    объекта. Затем, если он не был найден, это свойство запрашивается
    у объекта-прототипа. Если запрашиваемое свойство найдено не было, то
    возвращается \texttt{undefined}.
    %}::
    \item[\emph{Контекст выполнения}]~\\  %::{
      Когда управление передаётся выполняемому коду, осуществляется
      вход в контекст выполнения. Активные контексты выполнения
      логически формируют стек. Верхним контекстом выполнения в этом
      стеке является текущий контекст исполнения.

      Для каждого контекста выполнения имеется связанный с ним
      \emph{объект переменных}. Переменные и функции, определённые в
      исходном коде, добавляются в качестве свойств объекта
      переменных. Для кода функции параметры добавляются как свойства
      объекта переменных. Просмотр кода и добавление происходит при
      входе в контекст выполнения:
      % листинг ::{
      \begin{lstlisting}
	function foo() {
	  if (false) {
	    var a = 5;
	  } else {
	    print(a);
	    a = 10;
	    print(a);
	  }
	}

	function bar() {
	  print(a);
	  a = 11;
	}

	a = 20;
	foo();
	bar();
      \end{lstlisting}%}::
      После вызова первой функции будет выведено \texttt{undefined},
      \texttt{10}, a после вызова второй функции будет выведено
      \texttt{20} и значение глобальной переменной \texttt{a} станет
      \texttt{11}. Во время интерпретации кода в определённом
      контексте выполнения \emph{объект переменных} не изменяется
      %}::
    \item[\emph{Иерархия областей видимости}]~\\  %::{
      Для каждого контекста выполнения имеется связанная с ним
      иерархия областей видимости. Иерархия областей видимости --- это
      список объектов, в которых производится поиск при определении
      значения идентификаторов. Когда управление входит в контекст
      выполнения, создаётся иерархия областей видимости и сразу
      заполняется начальным набором объектов, зависящим от типа кода:
      \begin{itemize}
	\item При входе в глобальный код (например при запуске), в
	  иерархию добавляется только глобальный объект, который так
	  же будет \emph{объектом переменных} и \emph{объектом this}.
	\item При входе в функцию восстанавливается иерархия, хранящаяся
	  во внутреннем свойстве \inncom{Scope} вызываемой функции. Это
	  свойство сохраняется в момент определения функции. На вершину
	  восстановленной иерархии помещается \texttt{объект активации}.
      \end{itemize}
      При разрешение идентификаторов поочередно просматриваются все
      объекты в иерархии. В случае, если идентификатор отсутствует,
      при попытке чтения происходит ошибка, а при записи происходит
      неявное создание атрибута в текщем \texttt{объектке this}.
      % ГОН !!!!!!!
      Причина по которой атрибут не создается в текущем \emph{объекте
      переменных} --- семантика инструкции \texttt{with}.

      Во время интерпретации кода в определённом контексте выполнения
      на иерархию областей видимости могут влиять только инструкции
      \texttt{with} и \texttt{catch}.
    %}::
    \item[\emph{Объект Function}]~\\  %::{

% листинг ::{
\begin{lstlisting}
  function foo() {
    return bar();
  }

  function bar() {
    return new Date();
  }

  this.obj = condition() ? foo() : bar();
\end{lstlisting}
%}::

Значением члена \texttt{obj} объекта \texttt{this} будет ссылка на
объект \texttt{Date}. Если условие \texttt{condition()} истинно, то
объекту \texttt{Date} будет сопоставлен последовательность стековых
фреймов $\mathtt{this \rightarrow foo \rightarrow bar}$, если ложно то
$\mathtt{this \rightarrow bar}$. Последовательность стековых фреймов
объекта \texttt{this} не меняется в ходе этих операций.

    %}::
    \item[\emph{Вызов функции}]~\\  %::{
      \begin{enumerate}
	\item Иерархия областей видимости при инициализации содержит
	  \emph{объект активации}, за которым следуют объекты,
	  сохранённой в свойстве [[Scope]] объекта Function.

	  Когда управление входит в контекст выполнения кода
	  функции, объект, называемый \emph{объектом активации},
	  создаётся и связывается с контекстом выполнения. Объект
	  активации инициализируется с именем свойства
	  \texttt{arguments} и атрибутами \{ DontDelete \}. Начальным
	  значением этого свойства является \emph{объект аргументов}, 
	  который инициализируется следующим образом: 
	  \begin{enumerate}
	    \item Значение встроенного свойства [[Prototype]] для
	      объекта аргументов равно первоначальному
	      объекту-прототипу Object, т.е. тому, который
	      представляет собой первоначальное значение
	      Object.prototype

	    \item Создаётся свойство с именем callee и атрибутами \{
	      DontEnum \}. Первоначальное значение этого свойства -
	      объект Function, выполнение которого производится в
	      данный момент. Это позволяет анонимным функциям быть
	      рекурсивными.

	    \item Создаётся свойство с именем length и атрибутами \{
	      DontEnum \}. Начальным значением этого свойства является
	      число реальных значений аргументов, переданное при
	      вызове.

	    \item Для каждого неотрицательного числа arg, меньшего
	      значения свойства length создаётся свойство с именем
	      ToString(arg) и атрибутом { DontEnum }. Начальным
	      значением этого свойства является реальное значение
	      соответствующего аргумента, переданное при вызове.
	      Первое реальное значение аргумента соответствует arg =
	      0, второе - arg = 1 и так далее. В том случае, когда arg
	      меньше количества формальных параметров объекта
	      Function, значение свойства является общим с
	      соответствующим свойством объекта активации. Это
	      означает, что изменение данного свойства изменяет
	      соответствующее значение свойства у объекта активации и
	      наоборот.
	  \end{enumerate}

	  Объект активации затем используется в качестве
	  \emph{объекта переменных} при объявлении переменных.

	  Для программы на ECMAScript невозможно получить доступ к
	  объекту активации. Она может получать доступ к полям этого
	  объекта, но не к самому объекту. 
	  
	  Когда операция вызова применяется к значению Reference,
	  базовым объектом которого является объект активации, в
	  качестве значения this в таком вызове используется null.

	\item Инстанциация переменных производится при помощи объекта
	  активации в качестве объекта переменных и с использованием
	  атрибутов свойств \{ DontDelete \}.

	\item Значение this передаётся вызывающим. Если значение this,
	  переданное вызывающим, не является объектом (заметим, что
	  null - не объект), то значением this является глобальный
	  объект.
      \end{enumerate}


    %}::
    \item[\emph{Функции это объекты первого класса}]~\\  %::{
      Функции являются объектами первого класса: их можно передать как
      параметр в другую функцию, возвращать как результат работы другой
      функции, присваивать переменной и создавать во время исполнения.
      Разрешение идентификаторов функций происходит так же как и
      идентификаторов переменных.
    %}::
    \item[\emph{Интроспекция}]~\\  %::{
      В языке поддерживается интроспекция --- возможно добавление и
      удаление атрибутов объекта во время исполнения.
    %}::
    \item[\emph{Рефлексия}]~\\  %::{
      В языке поддерживается рефлексия возможность программы изменять
      свою структуру во время исполонения. Для этого используются
      инструкции \texttt{eval} и \texttt{Function}.
    %}::
    \item[\emph{Исключения}]~\\  %::{
    В языке поддерживаются исключения и операция безусловного перехода. При
    входе в \texttt{try} и в \texttt{catch} блоки создаются новые объекты
    видимости и помещаются в цепь объектов видимости. Объекты исключений не
    различаются, поэтому поддерживается использование только одного
    \texttt{catch} блока. Блок очистки \texttt{finally} выполняется
    всегда, даже после операции безусловного перехода.
    %}::
    % \item[\emph{Инструкция \texttt{with}}]~\\ %::{
    % Как и инструкция catch 

  % %}::
\end{description}
% }::

% vim: foldmethod=marker:foldmarker=\:\:{,}\:\:
